"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = exports.findElements = exports.findElement = exports.executeScript = exports.extractSelector = exports.toSimpleCommonSelector = exports.toSelector = exports.toElement = exports.toDriver = exports.isSecondarySelector = exports.isSelector = exports.isSecondaryElement = exports.isSecondaryDriver = void 0;
const spec = __importStar(require("@applitools/spec-driver-webdriver"));
const utils = __importStar(require("@applitools/utils"));
__exportStar(require("@applitools/spec-driver-webdriver"), exports);
const LEGACY_ELEMENT_ID = 'ELEMENT';
const ELEMENT_ID = 'element-6066-11e4-a52e-4f735466cecf';
const SHADOW_ROOT_ID = 'shadow-6066-11e4-a52e-4f735466cecf';
const DIRECT_SELECTOR_REGEXP = /^(id|css selector|xpath|link text|partial link text|name|tag name|class name|-android uiautomator|-android datamatcher|-android viewmatcher|-android viewtag|-ios uiautomation|-ios predicate string|-ios class chain|accessibility id):(.+)/;
async function getSearchRoot(driver, parent) {
    const root = driver.original;
    if (parent) {
        const elementId = parent[SHADOW_ROOT_ID] || parent[ELEMENT_ID] || parent[LEGACY_ELEMENT_ID];
        return root.$({ [ELEMENT_ID]: elementId });
    }
    return root;
}
function isSecondaryDriver(driver) {
    if (!driver)
        return false;
    return spec.isSecondaryDriver(driver) || utils.types.instanceOf(driver, 'Browser');
}
exports.isSecondaryDriver = isSecondaryDriver;
function isSecondaryElement(element) {
    return !!(element === null || element === void 0 ? void 0 : element.elementId);
}
exports.isSecondaryElement = isSecondaryElement;
function isSelector(selector) {
    return utils.types.isString(selector) || utils.types.has(selector, 'strategyName') || utils.types.isFunction(selector);
}
exports.isSelector = isSelector;
function isSecondarySelector(selector) {
    return spec.isSelector(selector);
}
exports.isSecondarySelector = isSecondarySelector;
function toDriver(driver) {
    if (spec.isSecondaryDriver(driver))
        return spec.toDriver(driver);
    if (!driver.isDevTools) {
        // NOTE: this function also could be used to populate missed webdriver commands
        return spec.toDriver(driver);
    }
    else {
        // NOTE: populating missing commands of devtools instance
        driver.addCommand('sendCommandAndGetResult', async (name, options) => {
            const puppeteer = await driver.getPuppeteer();
            const [page] = await puppeteer.pages();
            const session = await page.target().createCDPSession();
            return session.send(name, options);
        });
        return Object.create(driver, {
            original: { enumerable: false, get: () => driver },
        });
    }
}
exports.toDriver = toDriver;
function toElement(element) {
    if (utils.types.has(element, 'elementId')) {
        return {
            [ELEMENT_ID]: element.elementId,
            [LEGACY_ELEMENT_ID]: element.elementId,
            selector: isSelector(element.selector) ? element.selector : undefined,
        };
    }
    return element;
}
exports.toElement = toElement;
function toSelector(selector) {
    if (utils.types.has(selector, 'selector')) {
        if (utils.types.has(selector, 'type') && selector.type && utils.types.isString(selector.selector)) {
            return `${selector.type === 'css' ? 'css selector' : selector.type}:${selector.selector}`;
        }
        else if (isSelector(selector.selector)) {
            return selector.selector;
        }
        else {
            selector = selector.selector;
        }
    }
    if (utils.types.has(selector, ['using', 'value'])) {
        return `${selector.using}:${selector.value}`;
    }
    return selector;
}
exports.toSelector = toSelector;
function toSimpleCommonSelector(selector) {
    if (utils.types.isFunction(selector) || utils.types.has(selector, 'strategyName'))
        return null;
    else if (utils.types.isString(selector)) {
        const match = selector.match(DIRECT_SELECTOR_REGEXP);
        if (!match)
            return { selector };
        const [, using, value] = match;
        return { type: using === 'css selector' ? 'css' : using, selector: value };
    }
    return selector;
}
exports.toSimpleCommonSelector = toSimpleCommonSelector;
function extractSelector(element) {
    var _a;
    return (_a = element.selector) !== null && _a !== void 0 ? _a : null;
}
exports.extractSelector = extractSelector;
async function executeScript(driver, script, arg) {
    if (driver.original.isDevTools) {
        script = script.toString();
        script = script.startsWith('function') ? `return (${script}).apply(null, arguments)` : script;
        return driver.original.execute(runner, script.toString(), ...unwrap(arg));
    }
    return spec.executeScript(driver, script, arg);
    function runner(script, arg, ...elements) {
        return new Function(script).call(null, wrap(arg));
        function wrap(value) {
            if (value === 'pptr-element-marker') {
                return elements.shift();
            }
            else if (Array.isArray(value)) {
                return value.map(wrap);
            }
            else if (value && typeof value === 'object') {
                return Object.fromEntries(Object.entries(value).map(([key, value]) => [key, wrap(value)]));
            }
            else {
                return value;
            }
        }
    }
    function unwrap(arg) {
        if (!arg)
            return [];
        const elements = [];
        return [unwrap(arg), ...elements];
        function unwrap(value) {
            if (spec.isElement(value)) {
                elements.push(value);
                return 'pptr-element-marker';
            }
            else if (utils.types.isArray(value)) {
                return value.map(unwrap);
            }
            else if (utils.types.isObject(value)) {
                return Object.fromEntries(Object.entries(value).map(([key, value]) => [key, unwrap(value)]));
            }
            else {
                return value;
            }
        }
    }
}
exports.executeScript = executeScript;
async function findElement(driver, selector, parent) {
    const root = await getSearchRoot(driver, parent);
    try {
        const element = await root.$(selector);
        return !utils.types.has(element, 'error') ? spec.toElement(element) : null;
    }
    catch (error) {
        return null;
    }
}
exports.findElement = findElement;
async function findElements(driver, selector, parent) {
    const root = await getSearchRoot(driver, parent);
    const elements = await root.$$(selector);
    return Array.from(elements, spec.toElement);
}
exports.findElements = findElements;
const browserOptionsNames = {
    chrome: 'goog:chromeOptions',
    firefox: 'moz:firefoxOptions',
};
async function build(env) {
    let frameworkPath;
    try {
        frameworkPath = require.resolve('webdriverio', { paths: [`${process.cwd()}/node_modules`] });
    }
    catch {
        frameworkPath = 'webdriverio';
    }
    const { remote } = require(frameworkPath);
    const chromedriver = require('chromedriver');
    const parseEnv = require('@applitools/test-utils/src/parse-env');
    const { protocol, browser = '', emulation, capabilities, url, attach, proxy, configurable = true, args = [], headless, logLevel = 'silent', } = parseEnv(env, process.env.APPLITOOLS_FRAMEWORK_PROTOCOL);
    const options = {
        capabilities: { browserName: browser, ...capabilities },
        logLevel,
        connectionRetryCount: 0,
        connectionRetryTimeout: 2147483647 /* 32 bit positive int */,
    };
    if (browser === 'chrome' && protocol === 'cdp') {
        options.automationProtocol = 'devtools';
        options.capabilities[browserOptionsNames.chrome] = { args };
        options.capabilities['wdio:devtoolsOptions'] = {
            headless,
            ignoreDefaultArgs: ['--hide-scrollbars'],
        };
    }
    else if (protocol === 'wd') {
        options.automationProtocol = 'webdriver';
        options.protocol = url.protocol ? url.protocol.replace(/:$/, '') : undefined;
        options.hostname = url.hostname;
        if (url.port)
            options.port = Number(url.port);
        else if (options.protocol === 'http')
            options.port = 80;
        else if (options.protocol === 'https')
            options.port = 443;
        options.path = url.pathname;
        if (configurable) {
            if (browser === 'chrome' && attach) {
                await chromedriver.start(['--port=9515'], true);
                options.protocol = 'http';
                options.hostname = 'localhost';
                options.port = 9515;
                options.path = '/';
            }
            const browserOptionsName = browserOptionsNames[browser || options.capabilities.browserName];
            if (browserOptionsName) {
                const browserOptions = options.capabilities[browserOptionsName] || {};
                browserOptions.args = [...(browserOptions.args || []), ...args];
                if (headless)
                    browserOptions.args.push('headless');
                if (attach) {
                    browserOptions.debuggerAddress = attach === true ? 'localhost:9222' : attach;
                    if (browser !== 'firefox')
                        browserOptions.w3c = false;
                }
                options.capabilities[browserOptionsName] = browserOptions;
            }
        }
    }
    if (proxy) {
        options.capabilities.proxy = {
            proxyType: 'manual',
            httpProxy: proxy.http || proxy.server,
            sslProxy: proxy.https || proxy.server,
            ftpProxy: proxy.ftp,
            noProxy: proxy.bypass.join(','),
        };
    }
    const driver = await remote(options);
    if (driver.isDevTools && emulation) {
        const puppeteer = await driver.getPuppeteer();
        const [page] = await puppeteer.pages();
        if (emulation.deviceMetrics) {
            await page.setViewport({
                width: emulation.deviceMetrics.width,
                height: emulation.deviceMetrics.height,
                deviceScaleFactor: emulation.deviceMetrics.pixelRatio,
            });
        }
        if (emulation.userAgent) {
            await page.setUserAgent(emulation.userAgent);
        }
    }
    return [driver, () => driver.deleteSession().then(() => chromedriver.stop())];
}
exports.build = build;
